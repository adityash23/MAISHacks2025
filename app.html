<!DOCTYPE html>

<html lang="en">
    <head>
        
        <title>trAnSLate</title>
        <link rel="icon" type="image/png" href="">

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1, interactive-widget=resizes-content">


        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Fraunces:ital,opsz,wght@0,9..144,100..900;1,9..144,100..900&display=swap" rel="stylesheet">
    </head>

    <style>

     :root {
       --inputMode: "Gestures";
       --inputPrompt: "Click to begin recording";
       --outputMode: "Speech";
     }
     
     body {
       display: flex;
       flex-direction: column;
       justify-content: flex-start;
       align-items: center;
       height: 100vh;
       width: 100vw;
       margin: 0;
       gap: 5vh;
       overflow: hidden;
     }

     #title {
       width: min-content;
       font-family: Fraunces;
       font-weight: 200;
       font-size: 2.1rem;
       position: relative;
       padding:0;
       margin: 0;
       margin-top: 1.9vh;
       span {
         font-weight: 400;
       }
       &::before {
         content: "";
         width: 75%;
         height: 103%;
         position: absolute;
         left: 12.5%;
         border-radius: 3px;
       }
     }

     
     
     #info {
       font-family: Fraunces;
       font-size: 1.29rem;
       font-weight: 150;
       text-align: center;
       font-style: italic;
     }


     #input::before, #output::before {
       position: absolute;
       top: calc(-2rem - 1.1vh);
       font-size: 1.8rem;
       font-weight: 425;
       width: min-content;
       margin: 0;
       font-family: Fraunces;
       transition: transform 0.4s;
       z-index: -2;
       
     }

     #input.swapout::before {
       transform: translateY(3rem) rotate(-20deg);
     }

     #output.swapout::before {
       transform: translateY(3rem) rotate(20deg);
     }
     

     #input::before {content: var(--inputMode); }
     #output::before {content: var(--outputMode) ;}
     
     #wrap-convert {
       display: flex;
       flex-direction: row;
       justify-content: center;
       width: 90vw;
       gap: 2vw;
       align-items: center;
       align-content: center;
       flex-grow: 0.6;
       flex-wrap: wrap;
     }

     #swap {
       width: 45px;
       opacity: 0.8;
       cursor: pointer;
       background-image: url("assets/SWAP.svg");
       background-size: 100%;
       height: 45px;
       padding: 0;
       background-color: transparent;
       border: 0;
       transition: opacity 0.1s;

       &:hover {
         opacity: 0.5;
       }
     }

     #input, #output {
       height: 50vh;
       max-height: 60vh;
       max-width: 40vw;
       flex: 1 1 0px;
       border: 1px solid #C2C2C2;
       box-shadow: 0 0 4px #EFEFEF, 0 0 1px #DDD ;
       background: #FBFBFB;

       padding: 1vmin;

       box-sizing: border-box;
       border-radius: 10px;
       font-family: Fraunces;
       display: flex;
       flex-direction: column;
       position: relative;
       align-items: center;
     }

     #output {
       background-color: #EEE;
     }

     
     #input.loading #recordprompt {
       &::after { transition: opacity 0.1s; opacity: 0; }

       #record {
         animation: waiting 1s infinite;
       }
     }

     #input.recording #recordprompt {
       position: absolute;
       flex-direction: row;
       top: calc(15px + var(--vidHeight));
       
       #record {
         width: 30px;
         height: 30px;

         &::before {
           border-radius: 3px;
         }
       }

       &::after {transition-delay: 200ms;}
     }
     @keyframes waiting {
       0% {scale: 1;}
       50% {scale: 0.8;}
       100% {scale: 1;}
     }

     #recordprompt {
       margin-top: auto;
       margin-bottom: auto;
       display: flex;
       flex-direction: column;
       align-items: center;
       gap: 1vh;

       transition: top 0.2s ease-out;
       
       
       &::after {
         content: var(--inputPrompt);
         display: block;
         margin: 0;
         font-family: Fraunces;
       }
       
       #record {
         padding: 0;
         border: 0;
         background: transparent;
         border: 3px solid black;
         border-radius: 50%;

         cursor: pointer;
         width: 50px;
         height: 50px;
         transition: transform 0.1s, top 0.4s, width 0.2s, height 0.2s, border 0.3s;

         display: flex;
         justify-content: center;
         align-items: center;

         position: relative;

         &:hover::before, &:active::before {
           width: 65%;
           height: 65%;

         }

         &::before {
           background: hsl(3, 45%, 42%);
           content: "";
           width: 54%;
           height: 54%;
           display: block;
           border-radius: 50%;

           position: relative;
           

           transition: transform 0.1s, width 0.1s ease-out, height 0.1s ease-out;
         }

         
       }
     }
     
     #waveform {
       position: relative;
       margin-top: auto;
       margin-bottom: auto;
       width: 50px;
       opacity: 0.7;
     }

     #playprompt {
       margin-bottom: auto;
       display: flex;
       flex-direction: column;
       align-items: center;
       gap: 1vh;

       display: none;   
     }


     .prompt::after {
       font-weight: 300;
       font-size: 0.85rem;
       margin: 0;
       color: #888;
       opacity: 1;
       transition: opacity 0.2s ease-out;
     }
     
     #play {
       padding: 0;
       border: 0;
       background: url("assets/VOLUME.svg");
       background-size: 100%;

       cursor: pointer;
       opacity: 0.8;
       width: 30px;
       height: 30px;

       transition: transform 0.1s;

     }
     
     .nudged, .nudged::after, .nudged::before {
       transform: scale(0.95);
     }
     
     video {
       display: none;
     }
     #input.recording {
       transition: max-height 0.25s ease-out, max-width 0.25s ease-out;
       max-height: var(--vidHeight);
       max-width: var(--vidWidth);

       video {
         display: block;
         width: 100%;
         height: 100%;
       }

       
     }

    </style>

    <body>

        
        <h1 id="title"> tr<span>A</span>n<span>S</span><span>L</span>ate </h1>



        
        <div id="info"> Translate a sequence of letter signs into speech â€” and vice versa.  </div>

        

        <div id="wrap-convert">
            
            
            <div id="input">

                <div id="recordprompt" class="prompt">
                    <button id="record"></button>
                </div>

                <video id="livevid" autoplay="true"> </video>

            </div>
            
            <button id="swap"></button>

            
            <div id="output">
                
                <img id="waveform" src="assets/WAVEFORM.svg">

                <div id="playprompt" class="prompt">
                    <button id="play"></button>
                </div>

                
                
            </div>
        </div>
    </body>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>



    <script>

     
     const RECORD = document.getElementById("record");
     const SWAP = document.getElementById("swap");

     const INPUT = document.getElementById("input");
     const OUTPUT = document.getElementById("output");

     const VIDEO = document.getElementById("livevid");

     const PLAY = document.getElementById("play");

     

     let ratio = 1;

     let model;

     async function loadModel() {
       tf.loadLayersModel('tfjs_model_fixed/model.json').then((m) => {
         model = m;
         model.summary();
       }).catch((e) => {console.log(e)});
     }

     loadModel();



     function speak(text) {
       if ("speechsynthesis" in window) return;
       const SYNTH = window.speechSynthesis;
       const VOICES = SYNTH.getVoices();

       const utterance = new SpeechSynthesisUtterance('My name is Giulia Alberini');
       
       utterance.voice = VOICES[1];

       utterance.rate = 1; 

       utterance.pitch = 1;
       SYNTH.speak(utterance);    
     }


     function swapTitles() {
       let root = window.getComputedStyle(document.documentElement);

       [newInput, newOutput] = [ root.getPropertyValue("--outputMode"), root.getPropertyValue("--inputMode")];

       document.documentElement.style.setProperty("--inputMode", newInput);
       document.documentElement.style.setProperty("--outputMode", newOutput);

       INPUT.classList.remove("swapout");
       OUTPUT.classList.remove("swapout");

       INPUT.removeEventListener("transitionend", swapTitles);
     }
     
     SWAP.onclick = () => {
       
       INPUT.classList.add("swapout");
       OUTPUT.classList.add("swapout");

       INPUT.addEventListener("transitionend", swapTitles);
       

     };

     function captureFrames(vid) {
       let preview = document.createElement("canvas");
       var context = preview.getContext('2d')

       let img = new Image();
       
       setInterval(function () {
         context.drawImage(VIDEO, 0, 0, 640, 360);
         img.src = preview.toDataURL();
         img.width = VIDEO.getBoundingClientRect().width;
         img.height = VIDEO.getBoundingClientRect().height;

         predictFrame(img);
       }, 500);
     }

     
     function predictFrame(img) {
       console.log(tf.browser.fromPixels(img));
     }

     let recorder;

     RECORD.onclick = () => {
       if (INPUT.classList.contains("recording")) {
         recorder.ondataavailable = e => {
           let video = document.createElement("video");
           video.controls = true;
           video.src = URL.createObjectURL(e.data);
           video.style.display = 'block';
           video.style.width = '100%'; // Adjust as needed
           
           // Append the video to the page
           document.body.appendChild(video);
         };
         recorder.stop();
       }

       INPUT.classList.add("loading");

       INPUT.addEventListener("transitionend", () => {
         document.documentElement.style.setProperty("--inputPrompt", "'Loading stream...'");
         INPUT.classList.add("loadingmore");
       });
         
         navigator.mediaDevices
                  .getUserMedia({
                    audio: false,
                    video: true,
                  })
                  .then((stream) => {
                    const videoTracks = stream.getVideoTracks();

                    ratio = stream.getVideoTracks()[0].getSettings().aspectRatio;
                    resizeInput();

                    console.log(`Using video device: ${videoTracks[0].label}`);
                    stream.onremovetrack = () => {
                      console.log("Stream ended");
                    };

                    VIDEO.srcObject = stream;
                    document.documentElement.style.setProperty("--inputPrompt", "'Click to end recording'");
                    INPUT.classList.add("recording");

                    INPUT.classList.remove("loading");
                    INPUT.classList.remove("loadingmore");

                    captureFrames();
                    
                    recorder = new MediaRecorder(stream, {
                      mimeType: 'video/mp4'
                    });
                    recorder.start();


                  })
                  .catch((error) => {
                    if (error.name === "NotAllowedError") {
                      console.error(
                        "You need to grant this page permission to access your camera and microphone.",
                      );
                    } else {
                      console.error(`getUserMedia error: ${error.name}`, error);
                    }
                  });
     }

         function resizeInput() {
           let cardWidth = OUTPUT.clientWidth;
           let cardHeight = OUTPUT.clientHeight;

           let videoWidth, videoHeight;

           videoWidth = cardWidth;
           videoHeight = cardWidth / ratio;

           if (videoHeight > cardHeight) {
             videoHeight = cardHeight;
             videoWidth = cardHeight * ratio;
           }

           document.documentElement.style.setProperty("--vidWidth", `${videoWidth}px`);
           document.documentElement.style.setProperty("--vidHeight", `${videoHeight}px`);

         }

         window.onresize = () => {
           INPUT.style.transition = "none";
           resizeInput();
           INPUT.style.transition = "";
         };
         
         document.querySelectorAll("button").forEach(b => {
           b.addEventListener("pointerdown", (event) => {
             event.target.classList.add("nudged");
             event.target.addEventListener("pointerup", (event) => {
               event.target.classList.remove("nudged");
             });
             
           });
         });

         document.addEventListener("pointerup", () => {
           document.querySelectorAll(".nudged").forEach( n => {
             n.classList.remove("nudged");
           });
         });
    </script>
</html>


